#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot de scraping para HermessApp - Lista de Cumplea√±os
Extrae la informaci√≥n de cumplea√±os de los pacientes y la guarda en formato n8n
"""

import os
import json
import time
import requests
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from dotenv import load_dotenv

class HermessBirthdayBot:
    def __init__(self):
        """Inicializa el bot con configuraci√≥n desde variables de entorno"""
        load_dotenv('config.env')
        
        self.email = os.getenv('HERMESS_EMAIL')
        self.password = os.getenv('HERMESS_PASSWORD')
        self.login_url = os.getenv('HERMESS_LOGIN_URL', 'https://hermessapp.com/login')
        self.birthdays_url = os.getenv('HERMESS_BIRTHDAYS_URL', 'https://hermessapp.com/pacientescumple')
        self.n8n_webhook_url = os.getenv('N8N_WEBHOOK_URL') or os.getenv('n8n_workflow')
        
        if not self.email or not self.password:
            raise ValueError("Debes configurar HERMESS_EMAIL y HERMESS_PASSWORD en config.env")
        
        if not self.n8n_webhook_url:
            raise ValueError("Debes configurar N8N_WEBHOOK_URL o n8n_workflow en config.env")
        
        self.driver = None
        self.wait = None
        
    def setup_driver(self):
        """Configura el driver de Chrome con opciones optimizadas"""
        chrome_options = Options()
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--disable-gpu")
        chrome_options.add_argument("--window-size=1920,1080")
        chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        chrome_options.add_argument("--user-data-dir=/tmp/selenium")
        chrome_options.add_argument("--headless")
        
        self.driver = webdriver.Chrome(options=chrome_options)
        self.wait = WebDriverWait(self.driver, 10)
        
    def login(self):
        """Inicia sesi√≥n en HermessApp"""
        try:
            print("üîÑ Iniciando sesi√≥n en HermessApp...")
            self.driver.get(self.login_url)
            
            # Esperar a que cargue la p√°gina de login
            self.wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "form[action*='login']"))
            )
            
            # Buscar campos de login usando los selectores correctos del HTML
            email_field = self.driver.find_element(By.CSS_SELECTOR, "input[name='email']")
            password_field = self.driver.find_element(By.CSS_SELECTOR, "input[name='password']")
            
            # Ingresar credenciales
            email_field.clear()
            email_field.send_keys(self.email)
            
            password_field.clear()
            password_field.send_keys(self.password)
            
            # Buscar y hacer clic en el bot√≥n de login
            login_button = self.driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
            login_button.click()
            
            # Esperar a que se complete el login
            time.sleep(3)
            
            print("‚úÖ Sesi√≥n iniciada exitosamente")
            return True
            
        except Exception as e:
            print(f"‚ùå Error durante el login: {str(e)}")
            return False
    
    def navigate_to_birthdays(self):
        """Navega a la p√°gina de cumplea√±os"""
        try:
            print("üîÑ Navegando a la p√°gina de cumplea√±os...")
            self.driver.get(self.birthdays_url)
            time.sleep(3)
            
            # Hacer debug para ver qu√© hay en la p√°gina
            self._debug_page_content()
            
            # Esperar a que cargue alg√∫n contenido
            try:
                self.wait.until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, "body"))
                )
            except:
                pass
            
            print("‚úÖ P√°gina de cumplea√±os cargada")
            return True
            
        except Exception as e:
            print(f"‚ùå Error navegando a la p√°gina de cumplea√±os: {str(e)}")
            return False
    
    def _debug_page_content(self):
        """Hace debug del contenido de la p√°gina para entender su estructura"""
        try:
            print("üîç Analizando contenido de la p√°gina...")
            
            # Obtener el t√≠tulo de la p√°gina
            title = self.driver.title
            print(f"üìÑ T√≠tulo de la p√°gina: {title}")
            
            # Buscar texto que contenga "cumplea√±os"
            birthday_elements = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'cumplea√±os') or contains(text(), 'cumplea√±eros') or contains(text(), 'birthday')]")
            if birthday_elements:
                print(f"üéÇ Encontrados {len(birthday_elements)} elementos con texto de cumplea√±os:")
                for elem in birthday_elements[:3]:  # Solo mostrar los primeros 3
                    print(f"  - {elem.text[:100]}...")
            
            # Buscar formularios
            forms = self.driver.find_elements(By.CSS_SELECTOR, "form")
            print(f"üìù Encontrados {len(forms)} formularios")
            
            # Buscar tablas
            tables = self.driver.find_elements(By.CSS_SELECTOR, "table")
            print(f"üìä Encontradas {len(tables)} tablas HTML")
            
            # Buscar divs que puedan contener datos
            data_divs = self.driver.find_elements(By.CSS_SELECTOR, "div[class*='data'], div[class*='list'], div[class*='table']")
            print(f"üìã Encontrados {len(data_divs)} divs potenciales de datos")
            
            # Mostrar las primeras l√≠neas del HTML para debug
            page_source = self.driver.page_source
            if "cumplea√±os" in page_source.lower() or "cumplea√±eros" in page_source.lower():
                print("‚úÖ La p√°gina contiene texto relacionado con cumplea√±os")
            else:
                print("‚ö†Ô∏è No se encontr√≥ texto relacionado con cumplea√±os en la p√°gina")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error en debug: {str(e)}")
    
    def extract_birthday_data(self):
        """Extrae los datos de cumplea√±os de la tabla"""
        try:
            print("üîÑ Extrayendo datos de cumplea√±os...")
            
            # Esperar un poco m√°s para que la p√°gina cargue completamente
            time.sleep(2)
            
            # Buscar la tabla con selectores m√°s espec√≠ficos
            table_selectors = [
                "table",
                ".table",
                "[class*='table']",
                "div[role='table']",
                "[class*='list']",
                "div[class*='overflow']",  # Para tablas con scroll
                "div[class*='container']"  # Para contenedores de datos
            ]
            
            table = None
            for selector in table_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        # Verificar si el elemento contiene datos de cumplea√±os
                        if self._contains_birthday_data(element):
                            table = element
                            break
                    if table:
                        break
                except NoSuchElementException:
                    continue
            
            if not table:
                # Si no encontramos tabla, buscar por texto que contenga "cumplea√±os"
                try:
                    birthday_text = self.driver.find_element(By.XPATH, "//*[contains(text(), 'cumplea√±os') or contains(text(), 'cumplea√±eros')]")
                    print(f"üìç Encontrado texto relacionado: {birthday_text.text}")
                    # Buscar el contenedor padre que pueda contener la tabla
                    table = birthday_text.find_element(By.XPATH, "./ancestor::div[contains(@class, 'container') or contains(@class, 'table') or contains(@class, 'list')]")
                except:
                    pass
            
            if not table:
                raise Exception("No se pudo encontrar la tabla de cumplea√±os")
            
            print(f"üìç Tabla encontrada con selector: {table.tag_name}")
            
            # Extraer filas de la tabla
            rows = table.find_elements(By.CSS_SELECTOR, "tr, [role='row'], div[class*='row']")
            
            if not rows:
                # Si no hay filas, buscar elementos que parezcan filas de datos
                rows = table.find_elements(By.CSS_SELECTOR, "div[class*='item'], div[class*='entry'], div[class*='data']")
            
            print(f"üìç Encontradas {len(rows)} filas potenciales")
            
            birthdays_data = []
            
            for i, row in enumerate(rows):
                try:
                    # Buscar celdas con diferentes selectores
                    cells = row.find_elements(By.CSS_SELECTOR, "td, [role='cell'], div[class*='cell'], span, div")
                    
                    if len(cells) >= 3:  # M√≠nimo 3 columnas (nombre, fecha, edad)
                        # Extraer texto de las celdas
                        cell_texts = [cell.text.strip() for cell in cells if cell.text.strip()]
                        
                        if len(cell_texts) >= 3:
                            # Intentar identificar qu√© es cada columna
                            birthday_entry = self._parse_birthday_row(cell_texts)
                            if birthday_entry:
                                birthdays_data.append(birthday_entry)
                                print(f"  ‚úÖ Fila {i+1}: {birthday_entry['nombre']} - {birthday_entry['cumpleanos']}")
                        
                except Exception as e:
                    print(f"‚ö†Ô∏è Error procesando fila {i+1}: {str(e)}")
                    continue
            
            print(f"‚úÖ Se extrajeron {len(birthdays_data)} registros de cumplea√±os")
            return birthdays_data
            
        except Exception as e:
            print(f"‚ùå Error extrayendo datos: {str(e)}")
            return []
    
    def _contains_birthday_data(self, element):
        """Verifica si un elemento contiene datos de cumplea√±os"""
        try:
            text = element.text.lower()
            birthday_keywords = ['cumplea√±os', 'cumplea√±eros', 'fecha', 'edad', 'nombre']
            return any(keyword in text for keyword in birthday_keywords)
        except:
            return False
    
    def _parse_birthday_row(self, cell_texts):
        """Parsea una fila de datos de cumplea√±os"""
        try:
            # Buscar patrones comunes en los datos
            nombre = ""
            fecha = ""
            celular = ""
            edad = ""
            
            for text in cell_texts:
                text = text.strip()
                if not text:
                    continue
                
                # Identificar nombre (texto largo, sin n√∫meros)
                if len(text) > 5 and not any(char.isdigit() for char in text) and not nombre:
                    nombre = text
                
                # Identificar fecha (formato DD/MM o similar)
                elif '/' in text and len(text) <= 5 and not fecha:
                    fecha = text
                
                # Identificar celular (10 d√≠gitos)
                elif text.isdigit() and len(text) == 10 and not celular:
                    celular = text
                
                # Identificar edad (1-3 d√≠gitos)
                elif text.isdigit() and 1 <= len(text) <= 3 and not edad:
                    edad = text
            
            # Solo retornar si tenemos al menos nombre y fecha
            if nombre and fecha:
                # Convertir fecha a formato compatible con n8n (solo a√±o de ejecuci√≥n)
                cumpleanos = self._convert_date_to_n8n_format(fecha)
                
                # Formatear nombre con primera letra en may√∫scula
                nombre_formateado = self._format_name(nombre)
                
                return {
                    "nombre": nombre_formateado,
                    "cumpleanos": cumpleanos,
                    "celular": celular,
                    "edad": edad
                }
            
            return None
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error parseando fila: {str(e)}")
            return None
    
    def _reorder_name(self, nombre):
        """Reordena el nombre de 'Apellido1 Apellido2 Nombre1 Nombre2' a 'Nombre1 Nombre2 Apellido1 Apellido2'"""
        try:
            if not nombre:
                return nombre
            
            palabras = nombre.split()
            
            if len(palabras) < 2:
                return nombre
            
            # Estrategia inteligente para casos complejos
            if len(palabras) == 5:
                # Caso especial: DE LA OSSA TAMARA LUZ ANGELA
                # Patr√≥n: ApellidoCompuesto(3) + Apellido2(1) + Nombres(2)
                
                # Detectar apellidos compuestos comunes
                apellidos_compuestos_inicio = ['DE', 'DEL', 'VAN', 'VON', 'MAC', 'MC']
                
                if palabras[0].upper() in apellidos_compuestos_inicio:
                    # Verificar si es un apellido compuesto de 3 palabras
                    if palabras[0].upper() in ['DE', 'DEL'] and palabras[1].upper() in ['LA', 'LOS', 'LAS']:
                        # Patr√≥n: DE LA OSSA TAMARA LUZ ANGELA
                        # Apellido compuesto: DE LA OSSA (3 palabras)
                        # Segundo apellido: TAMARA (1 palabra)
                        # Nombres: LUZ ANGELA (2 palabras)
                        return f"{palabras[3]} {palabras[4]} {palabras[0]} {palabras[1]} {palabras[2]}"
                    elif palabras[0].upper() in ['VAN', 'VON'] and palabras[1].upper() == 'DER':
                        # Patr√≥n: VAN DER BERG CARLOS ALBERTO
                        # Apellido compuesto: VAN DER BERG (3 palabras)
                        # Nombres: CARLOS ALBERTO (2 palabras)
                        return f"{palabras[3]} {palabras[4]} {palabras[0]} {palabras[1]} {palabras[2]}"
                    else:
                        # Otros casos de apellidos compuestos de 2 palabras
                        # Patr√≥n: MAC DONALD JOHN MICHAEL
                        return f"{palabras[3]} {palabras[4]} {palabras[0]} {palabras[1]} {palabras[2]}"
                else:
                    # Patr√≥n est√°ndar: Apellido1 Apellido2 Apellido3 Nombre1 Nombre2
                    return f"{palabras[3]} {palabras[4]} {palabras[0]} {palabras[1]} {palabras[2]}"
            
            elif len(palabras) == 6:
                # Caso muy complejo: DE LA OSSA MARQUEZ TAMARA LUZ ANGELA
                # Patr√≥n: ApellidoCompuesto(3) + Apellido2(1) + Apellido3(1) + Nombres(2)
                
                apellidos_compuestos_inicio = ['DE', 'DEL', 'VAN', 'VON']
                
                if palabras[0].upper() in apellidos_compuestos_inicio:
                    if palabras[0].upper() in ['DE', 'DEL'] and palabras[1].upper() in ['LA', 'LOS', 'LAS']:
                        # Patr√≥n: DE LA OSSA MARQUEZ TAMARA LUZ ANGELA
                        # Apellidos: DE LA OSSA MARQUEZ (4 palabras)
                        # Nombres: TAMARA LUZ ANGELA (3 palabras)
                        # Pero esto es muy raro, usar l√≥gica de 3+3
                        return f"{palabras[3]} {palabras[4]} {palabras[5]} {palabras[0]} {palabras[1]} {palabras[2]}"
                    else:
                        # Otros casos complejos
                        mitad = len(palabras) // 2
                        apellidos = palabras[:mitad]
                        nombres = palabras[mitad:]
                        return f"{' '.join(nombres)} {' '.join(apellidos)}"
                else:
                    # L√≥gica general para 6 palabras
                    mitad = len(palabras) // 2
                    apellidos = palabras[:mitad]
                    nombres = palabras[mitad:]
                    return f"{' '.join(nombres)} {' '.join(apellidos)}"
            
            elif len(palabras) == 4:
                # Caso est√°ndar: Apellido1 Apellido2 Nombre1 Nombre2
                return f"{palabras[2]} {palabras[3]} {palabras[0]} {palabras[1]}"
            
            elif len(palabras) == 3:
                # Apellido1 Apellido2 Nombre1 ‚Üí Nombre1 Apellido1 Apellido2
                return f"{palabras[2]} {palabras[0]} {palabras[1]}"
            
            elif len(palabras) == 2:
                # Apellido1 Nombre1 ‚Üí Nombre1 Apellido1
                return f"{palabras[1]} {palabras[0]}"
            
            else:
                # Para otros casos, usar l√≥gica general
                mitad = len(palabras) // 2
                apellidos = palabras[:mitad]
                nombres = palabras[mitad:]
                return f"{' '.join(nombres)} {' '.join(apellidos)}"
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error reordenando nombre '{nombre}': {str(e)}")
            return nombre
    
    def _format_name(self, nombre):
        """Formatea el nombre con primera letra en may√∫scula y resto en min√∫sculas"""
        try:
            if not nombre:
                return nombre
            
            # Primero reordenar el nombre
            nombre_reordenado = self._reorder_name(nombre)
            
            # Dividir el nombre en palabras (por espacios)
            palabras = nombre_reordenado.split()
            
            # Formatear cada palabra
            palabras_formateadas = []
            for palabra in palabras:
                if palabra:
                    # Primera letra en may√∫scula, resto en min√∫sculas
                    palabra_formateada = palabra[0].upper() + palabra[1:].lower()
                    palabras_formateadas.append(palabra_formateada)
            
            # Unir las palabras con espacios
            return " ".join(palabras_formateadas)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error formateando nombre '{nombre}': {str(e)}")
            return nombre
    
    def _convert_date_to_n8n_format(self, fecha_dd_mm):
        """Convierte fecha DD/MM a formato YYYY-MM-DD usando siempre el a√±o de ejecuci√≥n"""
        try:
            if '/' not in fecha_dd_mm:
                return fecha_dd_mm
            
            # Separar d√≠a y mes
            partes = fecha_dd_mm.split('/')
            if len(partes) != 2:
                return fecha_dd_mm
            
            dia = int(partes[0])
            mes = int(partes[1])
            
            # Siempre usar el a√±o de ejecuci√≥n del script
            a√±o_ejecucion = datetime.now().year
            
            # Crear fecha completa con el a√±o de ejecuci√≥n
            fecha_completa = datetime(a√±o_ejecucion, mes, dia)
            
            # Formato ISO 8601 (YYYY-MM-DD) compatible con n8n
            return fecha_completa.strftime("%Y-%m-%d")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error convirtiendo fecha {fecha_dd_mm}: {str(e)}")
            return fecha_dd_mm
    
    def _remove_duplicates(self, data):
        """Elimina registros duplicados basados en nombre y celular"""
        try:
            seen = set()
            unique_data = []
            duplicates_removed = 0
            
            for entry in data:
                # Crear clave √∫nica basada en nombre y celular
                key = (entry.get('nombre', ''), entry.get('celular', ''))
                
                if key not in seen:
                    seen.add(key)
                    unique_data.append(entry)
                else:
                    duplicates_removed += 1
                    print(f"üîÑ Duplicado eliminado: {entry.get('nombre', 'Sin nombre')}")
            
            if duplicates_removed > 0:
                print(f"‚úÖ Se eliminaron {duplicates_removed} registros duplicados")
            
            return unique_data
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error eliminando duplicados: {str(e)}")
            return data
    
    def send_to_n8n_webhook(self, data):
        """Env√≠a los datos extra√≠dos al webhook de n8n"""
        # Eliminar duplicados antes de enviar
        data_unique = self._remove_duplicates(data)
        
        try:
            # Crear estructura de datos con metadatos para n8n
            payload = {
                "metadata": {
                    "fecha_extraccion": datetime.now().isoformat(),
                    "total_registros": len(data_unique),
                    "formato_fecha": "YYYY-MM-DD",
                    "a√±o_ejecucion": datetime.now().year,
                    "fuente": "HermessApp",
                    "descripcion": "Lista de cumplea√±os de pacientes extra√≠da autom√°ticamente"
                },
                "cumpleanos": data_unique
            }
            
            # Configurar headers para la petici√≥n
            headers = {
                'Content-Type': 'application/json',
                'User-Agent': 'HermessApp-Birthday-Bot/1.0'
            }
            
            print(f"üîÑ Enviando datos al webhook de n8n...")
            print(f"üìä Total de registros √∫nicos: {len(data_unique)}")
            print(f"üåê URL del webhook: {self.n8n_webhook_url}")
            
            # Enviar petici√≥n POST al webhook
            response = requests.post(
                self.n8n_webhook_url,
                json=payload,
                headers=headers,
                timeout=30
            )
            
            # Verificar respuesta
            if response.status_code == 200:
                print(f"‚úÖ Datos enviados exitosamente al webhook de n8n")
                print(f"üìä Total de registros enviados: {len(data_unique)}")
                print(f"üìÖ Formato de fecha: YYYY-MM-DD")
                print(f"üìÖ A√±o de ejecuci√≥n: {datetime.now().year}")
                return True
            else:
                print(f"‚ùå Error enviando datos al webhook. C√≥digo de respuesta: {response.status_code}")
                print(f"üìÑ Respuesta del servidor: {response.text}")
                return False
                
        except requests.exceptions.Timeout:
            print(f"‚ùå Timeout al enviar datos al webhook de n8n")
            return False
        except requests.exceptions.ConnectionError:
            print(f"‚ùå Error de conexi√≥n al webhook de n8n")
            return False
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error enviando datos al webhook: {str(e)}")
            return False
        except Exception as e:
            print(f"‚ùå Error inesperado enviando datos: {str(e)}")
            return False
    
    def run(self):
        """Ejecuta el bot completo"""
        try:
            print("üöÄ Iniciando bot de HermessApp...")
            
            self.setup_driver()
            
            if not self.login():
                return None
            
            if not self.navigate_to_birthdays():
                return None
            
            birthdays_data = self.extract_birthday_data()
            
            if birthdays_data:
                success = self.send_to_n8n_webhook(birthdays_data)
                if success:
                    print(f"üéâ Datos enviados exitosamente al webhook de n8n")
                    return birthdays_data
                else:
                    print("‚ùå Error enviando datos al webhook")
                    return None
            else:
                print("‚ùå No se pudieron extraer datos")
                return None
                
        except Exception as e:
            print(f"‚ùå Error general: {str(e)}")
            return None
            
        finally:
            if self.driver:
                self.driver.quit()
                print("üîí Navegador cerrado")

def main():
    """Funci√≥n principal"""
    try:
        bot = HermessBirthdayBot()
        result = bot.run()
        
        if result:
            print(f"\nüéâ Bot ejecutado exitosamente!")
            print(f"üìä Total de registros extra√≠dos: {len(result)}")
            print("\nüìã Primeros 3 registros:")
            for i, entry in enumerate(result[:3], 1):
                print(f"  {i}. {entry['nombre']} - {entry['cumpleanos']} ({entry['edad']} a√±os)")
        else:
            print("\n‚ùå El bot no pudo completar la tarea")
            
    except Exception as e:
        print(f"‚ùå Error en la ejecuci√≥n: {str(e)}")

if __name__ == "__main__":
    main()
